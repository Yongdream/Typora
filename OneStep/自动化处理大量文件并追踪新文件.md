### **技术方案改进：包含哈希校验的增量更新流程**

---

### **1. 服务器端的处理流程**

1. **解包 EXE 安装包**：
   
   - 使用 **7-Zip** 或其他工具解包安装包，将不同版本的文件解压到指定的目录中：
     ```bash
     7z x setup_v1.0.exe -o./extracted_v1.0
     7z x setup_v2.0.exe -o./extracted_v2.0
     ```
   
2. **生成差异包和追踪新文件**：
   - 使用脚本遍历旧版本和新版本目录，生成差异包，追踪新增文件。

   **Python 示例（生成差异包和追踪新文件）：**
   ```python
   import os
   import hashlib
   import subprocess
   
   def get_all_files(directory):
       file_paths = []
       for root, _, files in os.walk(directory):
           for file in files:
               file_paths.append(os.path.join(root, file))
       return file_paths
   
   def compute_sha256(file_path):
       sha256 = hashlib.sha256()
       with open(file_path, 'rb') as f:
           while chunk := f.read(8192):
               sha256.update(chunk)
       return sha256.hexdigest()
   
   def generate_diff_patch(old_version_dir, new_version_dir, patch_dir):
       old_files = get_all_files(old_version_dir)
       new_files = get_all_files(new_version_dir)
   
       patch_list = []
       new_file_list = []
   
       # 对现有文件生成差异包并计算哈希值
       for old_file in old_files:
           relative_path = os.path.relpath(old_file, old_version_dir)
           new_file = os.path.join(new_version_dir, relative_path)
   
           if os.path.exists(new_file):
               patch_file = os.path.join(patch_dir, relative_path + ".xdelta")
               os.makedirs(os.path.dirname(patch_file), exist_ok=True)
               command = ['xdelta3', '-e', '-s', old_file, new_file, patch_file]
               subprocess.run(command)
   
               patch_hash = compute_sha256(patch_file)
               patch_list.append({'file': relative_path, 'patch_file': patch_file, 'patch_hash': patch_hash})
           else:
               pass  # 文件已删除
   
       # 对新文件记录并计算哈希值
       for new_file in new_files:
           relative_path = os.path.relpath(new_file, new_version_dir)
           old_file = os.path.join(old_version_dir, relative_path)
   
           if not os.path.exists(old_file):
               new_file_hash = compute_sha256(new_file)
               new_file_list.append({'file': relative_path, 'file_url': f"http://example.com/{relative_path}", 'hash': new_file_hash})
   
       return patch_list, new_file_list
   
   # Example usage
   old_version_dir = './extracted_v1.0'
   new_version_dir = './extracted_v2.0'
   patch_dir = './patches'
   
   patches, new_files = generate_diff_patch(old_version_dir, new_version_dir, patch_dir)
   
   # 输出生成的差异包和新文件列表
   print("Generated patches:")
   for patch in patches:
       print(f"Patch: {patch['file']} -> {patch['patch_file']} (Hash: {patch['patch_hash']})")
   
   print("\nNew files:")
   for new_file in new_files:
       print(f"New file: {new_file['file']} -> {new_file['file_url']} (Hash: {new_file['hash']})")
   ```

3. **生成包含哈希校验的差异包列表**：
   - 输出生成的差异包和新文件列表，并附带哈希值，用于客户端校验文件完整性。

   **JSON 输出示例**：
   ```json
   {
       "patches": [
           {
               "file": "mysoftware.exe",
               "patch_file": "patches/mysoftware.exe.xdelta",
               "patch_hash": "abcd1234..."
           },
           {
               "file": "config.json",
               "patch_file": "patches/config.json.xdelta",
               "patch_hash": "efgh5678..."
           }
       ],
       "new_files": [
           {
               "file": "new_library.dll",
               "file_url": "http://example.com/new_library.dll",
               "hash": "ijkl9012..."
           }
       ]
   }
   ```

4. **服务器提供 API 接口**：
   - 当客户端请求更新时，服务器会根据版本号返回差异包和新增文件列表，并附带文件的哈希值，供客户端下载和校验。

### **2. 客户端的处理流程**

1. **获取更新信息**：
   - 客户端通过 HTTP 请求向服务器发送当前版本号，获取差异包和新增文件列表，包括文件的哈希值。

   **Python 示例**：
   ```python
   import requests
   
   def get_update_info(current_version):
       url = 'http://example.com/check_update'
       payload = {'current_version': current_version}
       response = requests.post(url, json=payload)
       return response.json() if response.status_code == 200 else None
   ```

2. **下载差异包和新增文件**：
   - 下载差异包和新增文件，并保存到本地。

   **Python 下载文件并校验哈希值的示例**：
   ```python
   import hashlib
   import requests
   
   def compute_sha256(file_path):
       sha256 = hashlib.sha256()
       with open(file_path, 'rb') as f:
           while chunk := f.read(8192):
               sha256.update(chunk)
       return sha256.hexdigest()
   
   def download_file_with_hash_check(url, save_path, expected_hash):
       response = requests.get(url, stream=True)
       if response.status_code == 200:
           with open(save_path, 'wb') as f:
               for chunk in response.iter_content(1024):
                   f.write(chunk)
           downloaded_hash = compute_sha256(save_path)
           if downloaded_hash == expected_hash:
               print(f"Downloaded {save_path} and hash verified.")
           else:
               print(f"Hash mismatch for {save_path}. Expected: {expected_hash}, but got: {downloaded_hash}")
       else:
           print(f"Failed to download {url}")
   
   # Example: 下载并校验差异包和新文件
   update_info = get_update_info("1.0")
   if update_info:
       for patch in update_info['patches']:
           download_file_with_hash_check(f"http://example.com/{patch['patch_file']}", f"./patches/{patch['file']}.xdelta", patch['patch_hash'])
   
       for new_file in update_info['new_files']:
           download_file_with_hash_check(new_file['file_url'], f"./new_files/{new_file['file']}", new_file['hash'])
   ```

3. **应用差异包**：
   - 使用 `xdelta3` 应用差异包更新现有文件。

   **Python 示例：**
   ```python
   import subprocess
   
   def apply_patch(old_file, patch_file, new_file):
       command = ['xdelta3', '-d', '-s', old_file, patch_file, new_file]
       subprocess.run(command, check=True)
       print(f"Patched {old_file} to {new_file}")
   
   # Example: Apply patches
   update_info = get_update_info("1.0")
   if update_info:
       for patch in update_info['patches']:
           apply_patch(f"./installed/{patch['file']}", f"./patches/{patch['file']}.xdelta", f"./installed/new_{patch['file']}")
   ```

4. **替换旧文件和处理新增文件**：
   - 下载完成并校验通过后，将新文件替换旧文件。

   **Python 示例**：
   ```python
   import os
   
   def replace_file(old_file, new_file):
       if os.path.exists(old_file):
           os.remove(old_file)
       os.rename(new_file, old_file)
       print(f"Replaced {old_file} with {new_file}")
   
   # Example: 替换旧文件
   replace_file("./installed/mysoftware.exe", "./installed/new_mysoftware.exe")
   replace_file("./installed/config.json", "./installed/new_config.json")
   
   # 处理新增文件
   os.replace("./new_files/new_library.dll", "./installed/new_library.dll")
   ```

### **总结：**

1. **服务器端**：
   - 使用脚本遍历文件夹生成差异包，并计算差异包和新增文件的哈希值。
   - 通过 API 返回差异包、新文件和对应的哈希值，确保客户端下载后可以校验完整性。

2. **客户端**：
   - 从服务器获取差异包和新增文件信息，并在下载后对文件进行哈希校验，确保文件未被篡改。
   - 使用 `xdelta3` 应用差异包更新本地文件，下载并处理新增文件，最后替换旧版本文件。

**哈希校验确保了更新